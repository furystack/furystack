---
name: Code Style
description: Formatting, naming conventions, import ordering, and file organization for FuryStack monorepo
globs:
  - '**/*.ts'
  - '**/*.tsx'
  - '**/*.js'
  - '**/*.jsx'
alwaysApply: true
---

# Code Style Guidelines

## Formatting Standards

### Prettier Configuration

This project uses Prettier for code formatting. **Always use the project's Prettier configuration**.

**Configuration file:** `prettier.config.js`

```bash
# ✅ Good - format code
yarn prettier

# ✅ Good - check formatting
yarn prettier:check
```

### ESLint Configuration

This project uses ESLint for code quality. **Always use the project's ESLint configuration**.

**Configuration file:** `eslint.config.js`

```bash
# ✅ Good - lint code
yarn lint
```

### Automated Formatting

Code is automatically formatted on commit via Husky:

```json
{
  "lint-staged": {
    "*.{ts,tsx}": ["eslint --fix", "prettier --write", "git add"]
  }
}
```

## Naming Conventions

### Package Names

- **kebab-case** with `@furystack/` scope
- Descriptive and concise

```
✅ Good:
@furystack/core
@furystack/rest-service
@furystack/shades
@furystack/logging

❌ Avoid:
@furystack/Core
@furystack/rest_service
@furystack/RestService
```

### Files and Directories

#### Source Files

- **kebab-case** for all files
- `.ts` for TypeScript, `.tsx` for JSX
- One main export per file

```
✅ Good:
packages/core/src/injectable.ts
packages/shades/src/shade.tsx
packages/rest-service/src/request-error.ts

❌ Avoid:
packages/core/src/Injectable.ts
packages/shades/src/Shade.tsx
packages/rest-service/src/RequestError.ts
```

#### Test Files

- **Same name as source** with `.spec.ts` suffix
- Co-located with source file

```
✅ Good:
packages/core/src/injectable.ts
packages/core/src/injectable.spec.ts

❌ Avoid:
packages/core/test/injectable.spec.ts (not co-located)
packages/core/src/injectable.test.ts (use .spec.ts)
```

### Exported Classes and Types

- **PascalCase** for classes, interfaces, types
- Descriptive and clear purpose

```typescript
// ✅ Good
export class Injectable {}
export class ObservableValue<T> {}
export type RequestAction<T> = {};
export interface InjectorOptions {}

// ❌ Avoid
export class injectable {} // Wrong case
export class IInjectableThing {} // Hungarian notation
```

### Functions and Variables

- **camelCase** for functions and variables
- **UPPER_SNAKE_CASE** for constants

```typescript
// ✅ Good
export function getCurrentUser() {}
export const isAuthenticated = true;
export const MAX_RETRY_COUNT = 3;

// ❌ Avoid
export function GetCurrentUser() {}
export const IsAuthenticated = true;
export const maxRetryCount = 3; // Should be UPPER_SNAKE_CASE for constants
```

## Package Structure

### Monorepo Organization

```
packages/
├── core/
│   ├── src/
│   │   ├── index.ts          # Main export
│   │   ├── injectable.ts
│   │   ├── injectable.spec.ts
│   │   └── types.ts
│   ├── package.json
│   └── tsconfig.json
├── shades/
│   ├── src/
│   │   ├── index.ts
│   │   ├── shade.tsx
│   │   └── shade.spec.ts
│   └── package.json
└── rest-service/
    ├── src/
    │   ├── index.ts
    │   ├── request-error.ts
    │   └── request-action.ts
    └── package.json
```

### Package Exports

Each package should have a clear `index.ts`:

```typescript
// ✅ Good - packages/core/src/index.ts
export { Injectable, Injected } from './injectable.js';
export { Injector } from './injector.js';
export type { InjectorOptions } from './types.js';

// Re-export commonly used types
export type { Constructor } from './types.js';
```

## Import Ordering

### Import Order for Packages

1. **Node built-ins**
2. **External dependencies**
3. **Other FuryStack packages** (`@furystack/*`)
4. **Relative imports from same package**
5. **Type imports** (if separated)

```typescript
// ✅ Good - organized imports
import { EventEmitter } from 'events';

import type { Logger } from 'winston';

import { Injectable } from '@furystack/inject';
import { ObservableValue } from '@furystack/utils';

import { getUserData } from './user-data.js';
import type { UserOptions } from './types.js';

// ❌ Avoid - random ordering
import { getUserData } from './user-data.js';
import { EventEmitter } from 'events';
import { Injectable } from '@furystack/inject';
```

### Import Grouping

Separate import groups with blank lines:

```typescript
// ✅ Good - separated groups
import { EventEmitter } from 'events';

import type { Logger } from 'winston';

import { Injectable } from '@furystack/inject';

import { getUserData } from './user-data.js';
```

## Code Organization

### Class Structure

```typescript
// ✅ Good - organized class
export class MyService {
  // 1. Static properties
  private static instance: MyService;

  // 2. Public properties
  public data: string;

  // 3. Private properties
  private internalState: number;

  // 4. Constructor
  constructor(options: MyServiceOptions) {
    this.data = options.data;
    this.internalState = 0;
  }

  // 5. Public methods
  public getData(): string {
    return this.data;
  }

  // 6. Private methods
  private updateInternalState(value: number): void {
    this.internalState = value;
  }

  // 7. Disposal
  public [Symbol.dispose](): void {
    // Cleanup
  }
}
```

### File Structure

```typescript
// 1. Imports
import { Injectable } from '@furystack/inject';
import { ObservableValue } from '@furystack/utils';

// 2. Types
type ServiceOptions = {
  config: string;
};

// 3. Constants
const DEFAULT_TIMEOUT = 5000;

// 4. Helper functions
const formatData = (data: unknown): string => {
  return JSON.stringify(data);
};

// 5. Main exports
@Injectable({ lifetime: 'singleton' })
export class DataService {
  // Class implementation
}
```

## Comments and Documentation

### JSDoc for Public APIs

All exported functions, classes, and types should have JSDoc:

```typescript
/**
 * Creates an injectable decorator for dependency injection
 * @param options - Configuration options for the injectable
 * @returns Decorated class with injection metadata
 */
export function Injectable(options: InjectableOptions): ClassDecorator {
  // Implementation
}

/**
 * Observable value container for reactive state management
 * @typeParam T - The type of value stored in the observable
 */
export class ObservableValue<T> {
  /**
   * Creates a new ObservableValue
   * @param initialValue - The initial value
   */
  constructor(private initialValue: T) {}

  /**
   * Gets the current value
   * @returns The current value
   */
  public getValue(): T {
    return this.initialValue;
  }
}
```

## Summary

**Key Principles:**

1. **Follow project's Prettier and ESLint configs**
2. **Use consistent naming:**
   - PascalCase: Classes, types, interfaces
   - camelCase: Functions, variables
   - kebab-case: File names, package names
   - UPPER_SNAKE_CASE: Constants
3. **Organize packages** with clear exports
4. **Order imports** by category with blank lines
5. **Document public APIs** with JSDoc
6. **Structure code** consistently
7. **Monorepo conventions** for package organization

**Tools:**

- Prettier: `yarn prettier`
- ESLint: `yarn lint`
- Type Check: `yarn build`
